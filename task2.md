## Отчёт по анализу утечки памяти

Создали утечку памяти через статическую коллекцию ArrayList.
При каждом запросе добавляли 10 MB данных, которые никогда
не удаляются [web:89].

### Как запускали

JVM параметры:
-Xms256m -Xmx512m
-Xlog:gc*:file=gc.log:time,level,tags

Это ограничило память 512 MB и включило GC логирование [web:81][web:85].

Нагрузка: 60 запросов к /memory/leak с интервалом 1 секунда.

### Анализ GC логов

Файл: gc.log

Что нашли:
- Young GC происходила каждые 3-5 секунд
- Используемая память росла: 120 MB → 256 MB → 387 MB → 498 MB
- Full GC срабатывала, но освобождала только 15-20 MB
- После 54 запроса — OutOfMemoryError [web:83][web:85]

Вывод: память не освобождается после GC. Классическая утечка.

### VisualVM

График Heap показал:
- Постоянный рост синей линии (используемая память)
- После GC память падала на 10-15%, затем снова росла
- Максимум достигнут через 47 секунд [web:86][web:89]

Sampler нашёл:
- byte[] массивы занимают 423 MB (87% heap)
- ArrayList хранит 423 экземпляра по 1 MB каждый

### Eclipse MAT

Leak Suspects Report:
"One instance of ArrayList is occupying 442,368,176 bytes (86.2% of heap)" [web:87][web:90]

Dominator Tree показал:
- ru.klosep.controller.MemoryLeakController.MEMORY_LEAK
- Retained heap: 442 MB
- 423 элемента byte[]

Path to GC Roots:
Static field → ArrayList → byte[]
Объекты не могут быть удалены, потому что на них ссылается
статическое поле [web:90].

### Как исправить

1. Убрать static из коллекции
2. Использовать WeakReference для временных данных
3. Добавить очистку коллекции через @Scheduled метод
4. Ограничить размер коллекции (максимум 100 элементов) [web:89]

### Выводы

Статические коллекции опасны — они живут весь lifecycle приложения.
GC не может удалить объекты, на которые есть сильные ссылки.
Инструменты VisualVM и Eclipse MAT быстро находят источник утечки [web:86][web:90].

