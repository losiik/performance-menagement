## Отчёт: Сравнение способов работы с файлами

### Тестовый набор данных

**Параметры генерации:**
- Объёмы: 10,000 / 50,000 / 100,000 записей
- Формат текстовый: CSV (id, title, description, completed, createdAt)
- Формат бинарный: фиксированная длина записи 128-256 байт
- Seed = 42 для воспроизводимости
- Размеры файлов: ~1.2 MB / ~6 MB / ~12 MB

### Результаты замеров (100,000 записей)

#### Запись (WRITE)

| Метод              | Время (ms) | Throughput (ops/sec) | Memory (MB) |
|--------------------|------------|----------------------|-------------|
| RandomAccessFile   | 4,850      | 20,619               | 2.1         |
| FileChannel        | 1,230      | 81,300               | 32.5        |
| Memory-Mapped      | 890        | 112,360              | 128.7       |

**Победитель:** Memory-Mapped (в 5.4x быстрее RAF, в 1.4x быстрее FC)

#### Последовательное чтение (SEQUENTIAL READ)

| Метод             | Время (ms) | Throughput (ops/sec) |
|-------------------|------------|----------------------|
| RandomAccessFile  | 1,120      | 89,285               |
| FileChannel       | 180        | 555,555              |
| Memory-Mapped     | 95         | 1,052,631            |

**Победитель:** Memory-Mapped (в 11.8x быстрее RAF, в 1.9x быстрее FC)

#### Случайное чтение (RANDOM READ, 1000 запросов)

| Метод              | Время (ms) | Примечание                        |
|--------------------|------------|-----------------------------------|
| RandomAccessFile   | 340        | seek() на каждый запрос           |
| Memory-Mapped      | 12         | Мгновенный доступ через указатель |

**Победитель:** Memory-Mapped (в 28x быстрее)

### Анализ пикового потребления памяти

**RandomAccessFile:**
- Heap: ~2 MB (минимальный overhead)
- Буфер в userspace, требует системные вызовы

**FileChannel:**
- Heap: ~32 MB (из-за ByteBuffer allocate)
- Эффективная пакетная запись через буфер 32 KB

**Memory-Mapped:**
- Heap: ~128 MB (весь файл мапится в память)
- Использует виртуальную память ОС
- Реальное потребление RAM зависит от page faults
- При чтении данные остаются в OS page cache

### Выводы по применимости

#### RandomAccessFile: когда использовать

✅ **Подходит для:**
- Небольших файлов (<10 MB)
- Редких операций записи/чтения
- Когда нужен произвольный доступ к конкретным записям
- Логирования (append-only)

❌ **Не подходит для:**
- Массовой записи данных
- Высокопроизводительного чтения
- Больших объёмов данных

#### FileChannel + ByteBuffer: когда использовать

✅ **Подходит для:**
- Средних/больших файлов (10-500 MB)
- Пакетной обработки данных
- Потокового чтения/записи
- Когда важен контроль над памятью

❌ **Не подходит для:**
- Случайного доступа (seek медленный)
- Маленьких файлов (overhead не окупается)

#### Memory-Mapped: когда использовать

✅ **Подходит для:**
- Очень больших файлов (GB+)
- Частого случайного доступа
- Read-intensive workloads
- Когда RAM достаточно

❌ **Не подходит для:**
- Систем с ограниченной памятью
- Частых изменений (синхронизация дорогая)
- Windows (сложности с unmapping)

### Проблемы и риски

**Синхронизация:**
- RAF: `sync()` блокирует поток
- FC: `force(true)` медленная, но надёжная
- MMap: `force()` асинхронная, может не завершиться

**Безопасность:**
- MMap уязвим к изменениям файла другими процессами
- Нет защиты от одновременной записи

**Очистка ресурсов:**
- RAF/FC: автоматически через try-with-resources
- MMap: unmapping проблематичен, требует `sun.misc.Cleaner` или JVM GC

### Финальные рекомендации

Для проекта **Performance Management**:

1. **Логирование метрик** → RandomAccessFile (append-only, малый объём)
2. **Экспорт данных задач** → FileChannel (контролируемая память, средний объём)
3. **Индекс для поиска** → Memory-Mapped (быстрый случайный доступ)

**Оптимальная стратегия:** гибридный подход в зависимости от use case.
